2019-02-12 17:21:16.259-->{"code":0,"msg":"","count":12,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"},{"KID":"43489.550699838","Title":"初学DevOps-1","TitleDescription":"DevOps","Category":"技术","Content":"随着软件发布迭代的频率越来越高，传统的「瀑布型」（开发―测试―发布）模式已经不能满足快速交付的需求。2009&nbsp;年左右&nbsp;DevOps&nbsp;应运而生，简单地来说，就是更好的优化开发(DEV)、测试(QA)、运维(OPS)的流程，开发运维一体化，通过高度自动化工具与流程来使得软件构建、测试、发布更加快捷、频繁和可靠。<br/>一、那么究竟什么是DevOps呢？<br/>DevOps&nbsp;是一个完整的面向IT运维的工作流，以&nbsp;IT&nbsp;自动化以及持续集成（CI）、持续部署（CD）为基础，来优化程式开发、测试、系统运维等所有环节。<br/>二、DevOps有什么好处和价值？<br/>a、代码的提交直接触发：消除等待时间，快速反馈；<br/>b、每个变化对应一个交付管道：使问题定位和调试变得简单<br/>c、全开发流程高效自动化：稳定，快速，交付结果可预测<br/>d、持续进行自动化回归测试：提升交付质量<br/>e、设施共享并按需提供：资源利用最大化<br/><br/>DevOps&nbsp;的好处更多基于在于持续部署与交付，这是对于业务与产品而言。而&nbsp;DevOps&nbsp;始于接受&nbsp;DevOps&nbsp;文化与技术方法论，它是部门间沟通协作的一组流程和方法，有助于改善公司组织文化、提高员工的参与感。<br/>DevOps&nbsp;Tools&nbsp;的技术关键点:<br/>1.Automated&nbsp;infrastructure（自动化，系统之间的集成）<br/>2.shared&nbsp;version&nbsp;control（SVN共享源码）&nbsp;<br/>3.one&nbsp;step&nbsp;build&nbsp;and&nbsp;deploy（持续构建和部署）<br/>4.feature&nbsp;flags（主干开发）<br/>5.Shared&nbsp;metrics<br/>6.IRC&nbsp;and&nbsp;IM&nbsp;robots（信息整合）<br/><br/>DevOps&nbsp;=&nbsp;Culture&nbsp;+&nbsp;Tools<br/><br/>有用的devopsmarks站点：<br/>http://www.devopsbookmarks.com","Author":"Jacee","ImgUrl":"assets/articleImg/初学DevOps-1.jpg","CreateDate":"2017-10-18T00:00:00"},{"KID":"43493.7173055208","Title":"初学DevOps-2","TitleDescription":"DevOps","Category":"技术","Content":"DevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。[1]&nbsp;它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。<br/><br/>以下几方面因素可能促使一个组织引入DevOps：<br/>1、使用敏捷或其他软件开发过程与方法<br/>2、业务负责人要求加快产品交付的速率<br/>3、虚拟化和云计算基础设施（可能来自内部或外部供应商）日益普遍<br/>4、数据中心自动化技术和配置管理工具的普及<br/>5、有一种观点认为，目前占主导地位的“传统”美国式管理风格（“斯隆模型&nbsp;vs&nbsp;丰田模型”）会导致“烟囱式自动化”，从而造成开发与运营之间的鸿沟，因此需要DevOps能力来克服由此引发的问题。<br/><br/>实现DevOps需要什么？<br/>1、硬性要求：工具上的准备，现将工具类型及对应的不完全列举整理如下：<br/><br/>代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion<br/><br/>构建工具：Ant、Gradle、maven<br/><br/>自动部署：Capistrano、CodeDeploy<br/><br/>持续集成（CI）：Bamboo、Hudson、Jenkins<br/><br/>配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock&nbsp;GuardRail<br/><br/>容器：Docker、LXC、第三方厂商如AWS<br/><br/>编排：Kubernetes、Core、Apache&nbsp;Mesos、DC/OS<br/><br/>服务注册与发现：Zookeeper、etcd、Consul<br/><br/>脚本语言：python、ruby、shell<br/><br/>日志管理：ELK、Logentries<br/><br/>系统监控：Datadog、Graphite、Icinga、Nagios<br/><br/>性能监控：AppDynamics、New&nbsp;Relic、Splunk<br/><br/>压力测试：JMeter、Blaze&nbsp;Meter、loader.io<br/><br/>预警：PagerDuty、pingdom、厂商自带如AWS&nbsp;SNS<br/><br/>HTTP加速器：Varnish<br/><br/>消息总线：ActiveMQ、SQS<br/><br/>应用服务器：Tomcat、JBoss<br/><br/>Web服务器：Apache、Nginx、IIS<br/><br/>数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库<br/><br/>项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal&nbsp;Tracker<br/><br/>在工具的选择上，需要结合公司业务需求和技术团队情况而定。<br/>2、软性需求：文化和人<br/><br/>DevOps成功与否，公司组织是否利于协作是关键。开发人员和运维人员可以良好沟通互相学习，从而拥有高生产力。并且协作也存在于业务人员与开发人员之间。<br/><br/>出席了2016年伦敦企业级DevOps峰会的ITV公司在2012年就开始落地DevOps，其通用平台主管Clark在接受了InfoQ的采访，在谈及成功时表示，业务人员非常清楚他们希望在最小化可行产品中实现什么，工程师们就按需交付，不做多余工作。<br/><br/>这样，工程师们使用通用的平台（即打通的工具链）得到更好的一致性和更高的质量。此外，DevOps对工程师个人的要求也提高了，很多专家也认为招募到优秀的人才也是一个挑战。<br/><br/>在工具层面上，DevOps工具的用量大幅激增。Chef和Puppet依然是最常用的DevOps工具，使用率均为32%。Docker是年增长率最快的工具，用量增长一倍以上。Ansible的用量也有显著增加，使用率从10%翻倍至20%。","Author":"Jacee","ImgUrl":"assets/articleImg/初学DevOps-2.jpg","CreateDate":"2017-10-23T00:00:00"},{"KID":"43507.7062626389","Title":".NET设计模式-4:原型模式（Prototype&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;原型模式","Category":"技术","Content":"在软件系统中，当创建一个类的实例的过程很昂贵或很复杂，并且我们需要创建多个这样类的实例时，如果我们用new操作符去创建这样的类实例，这未免会增加创建类的复杂度和耗费更多的内存空间，因为这样在内存中分配了多个一样的类实例对象，然后如果采用工厂模式来创建这样的系统的话，随着产品类的不断增加，导致子类的数量不断增多，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适，然而原型模式可以很好地解决这个问题，因为每个类实例都是相同的，当我们需要多个相同的类实例时，没必要每次都使用new运算符去创建相同的类实例对象，此时我们一般思路就是想――只创建一个类实例对象，如果后面需要更多这样的实例，可以通过对原来对象拷贝一份来完成创建，这样在内存中不需要创建多个相同的类实例，从而减少内存的消耗和达到类实例的复用。&nbsp;然而这个思路正是原型模式的实现方式：<br/>在现实生活中，也有很多原型设计模式的例子，例如，细胞分裂的过程，一个细胞的有丝分裂产生两个相同的细胞；还有西游记中孙悟空变出后孙的本领和火影忍者中鸣人的隐分身忍术等。下面就以孙悟空为例子来演示下原型模式的实现。具体的实现代码如下：<br/>///火影忍者中鸣人的影分身和孙悟空的的变都是原型模式<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Client<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;孙悟空&nbsp;原型<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MonkeyKingPrototype&nbsp;prototypeMonkeyKing&nbsp;=&nbsp;new&nbsp;ConcretePrototype(\"MonkeyKing\");<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;变一个<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MonkeyKingPrototype&nbsp;cloneMonkeyKing&nbsp;=&nbsp;prototypeMonkeyKing.Clone()&nbsp;as&nbsp;ConcretePrototype;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"Cloned1:\\t\"+cloneMonkeyKing.Id);<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;变两个<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MonkeyKingPrototype&nbsp;cloneMonkeyKing2&nbsp;=&nbsp;prototypeMonkeyKing.Clone()&nbsp;as&nbsp;ConcretePrototype;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"Cloned2:\\t\"&nbsp;+&nbsp;cloneMonkeyKing2.Id);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadLine();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;孙悟空原型<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;abstract&nbsp;class&nbsp;MonkeyKingPrototype<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Id&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MonkeyKingPrototype(string&nbsp;id)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Id&nbsp;=&nbsp;id;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;克隆方法，即孙大圣说“变”<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;MonkeyKingPrototype&nbsp;Clone();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;创建具体原型<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;ConcretePrototype&nbsp;:&nbsp;MonkeyKingPrototype<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcretePrototype(string&nbsp;id)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;base(id)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;浅拷贝<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<returns></returns><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;MonkeyKingPrototype&nbsp;Clone()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调用MemberwiseClone方法实现的是浅拷贝，另外还有深拷贝<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(MonkeyKingPrototype)this.MemberwiseClone();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>从运行结果可以看出，创建的两个拷贝对象的ID属性都是与原型对象ID属性一样的。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式原型模式01.jpg","CreateDate":"2016-04-26T00:00:00"},{"KID":"43507.712107581","Title":".NET设计模式-4:原型模式（Prototype&nbsp;Pattern）-2","TitleDescription":".NET设计模式:原型模式","Category":"技术","Content":"1、从上次的转载的文章代码中可以看出：实现的浅拷贝的方式，浅拷贝是指当对象的字段值被拷贝时，字段引用的对象不会被拷贝。例如，如果一个对象有一个指向字符串的字段，并且我们对该对象做了一个浅拷贝，那么这两个对象将引用同一个字符串，而深拷贝是对对象实例中字段引用的对象也进行拷贝，如果一个对象有一个指向字符串的字段，并且我们对该对象进行了深拷贝的话，那么我们将创建一个对象和一个新的字符串，新的对象将引用新的字符串。也就是说，执行深拷贝创建的新对象和原来对象不会共享任何东西，改变一个对象对另外一个对象没有任何影响，而执行浅拷贝创建的新对象与原来对象共享成员，改变一个对象，另外一个对象的成员也会改变。<br/>2、原型模式的优点有：<br/>原型模式向客户隐藏了创建新实例的复杂性<br/>原型模式允许动态增加或较少产品类。<br/>原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。<br/>产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构<br/>原型模式的缺点有：<br/>每个类必须配备一个克隆方法<br/>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。<br/>3、.NET中原型模式的实现<br/>在.NET中可以很容易地通过实现ICloneable接口（这个接口就是原型，提供克隆方法，相当于与上面代码中MonkeyKingPrototype抽象类）中Clone()方法来实现原型模式，如果我们想我们自定义的类具有克隆的功能，首先定义类继承与ICloneable接口并实现Clone方法。<br/>到这里关于原型模式的介绍就结束了，原型模式用一个原型对象来指明所要创建的对象类型，然后用复制这个原型对象的方法来创建出更多的同类型对象，它与工厂方法模式的实现非常相似，其中原型模式中的Clone方法就类似工厂方法模式中的工厂方法，只是工厂方法模式的工厂方法是通过new运算符重新创建一个新的对象（相当于原型模式的深拷贝实现），而原型模式是通过调用MemberwiseClone方法来对原来对象进行拷贝，也就是复制，同时在原型模式优点中也介绍了与工厂方法的区别（第三点）。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式原型模式02.jpg","CreateDate":"2016-04-26T00:00:00"}]}
