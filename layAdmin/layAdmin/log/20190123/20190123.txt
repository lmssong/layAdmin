2019-01-23 14:47:37.363-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:47:52.892-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:48:00.308-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:51:01.460-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:53:40.884-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:44.821-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:49.197-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:51.430-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:53.969-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:54.055-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:54.679-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:54.807-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:56:56.963-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:57:20.468-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 14:57:22.846-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 15:10:23.955-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 15:10:36.729-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 15:10:44.422-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 15:19:11.151-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 15:32:38.228-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 15:33:17.164-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 15:34:00.377-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 16:11:14.813-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 16:16:49.576-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 16:25:16.149-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 16:25:51.548-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 16:26:16.884-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:04:45.408-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:07:08.474-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:07:56.040-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:09:40.572-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:10:23.594-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:13:46.627-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:17:30.375-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:17:33.401-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:18:26.012-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:18:52.490-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
2019-01-23 17:19:15.851-->{"code":0,"msg":"","count":8,"data":[{"KID":"43484.6587888542","Title":"mysql填坑系列-1","TitleDescription":"mysql","Category":"技术","Content":"由于项目需要，最近在捣鼓mysql相关工作，其中不免有踩到几个坑，这里记录了下来，以示后期更少的误入坑中。<br/>1、ef+mysql遇坑<br/>错误信息：<br/>方法“MySql.Data.MySqlClient.MySqlProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)”尝试访问方法“MySql.Data.MySqlClient.MySqlConnection.get_Settings()”失败。<br/>System.Data.Entity.Core.ProviderIncompatibleException:“The&nbsp;provider&nbsp;did&nbsp;not&nbsp;return&nbsp;a&nbsp;ProviderManifestToken&nbsp;string.”<br/><br/>解决方法：<br/>MySql.Data&nbsp;和MySql.Data.Entity.EF6的版本必须一致，这里采用6.10.8版本。<br/>2、SQLyog连接数据库报错plugin&nbsp;caching_sha2_password&nbsp;could&nbsp;not&nbsp;be&nbsp;loaded:<br/><br/>解决方法：<br/>打开cmd：mysql&nbsp;-uroot&nbsp;-p?<br/><br/>进入mysql依次执行下面语句<br/>&nbsp;#修改加密规则?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;BY&nbsp;'password'&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;<br/>#更新一下用户的密码?<br/>ALTER&nbsp;USER&nbsp;'root'@'localhost'&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;'password';&nbsp;<br/>&nbsp;#刷新权限<br/>FLUSH&nbsp;PRIVILEGES;<br/>#重置自己的密码<br/>alter&nbsp;user&nbsp;'root'@'localhost'&nbsp;identified&nbsp;by&nbsp;'xzx123456';<br/>3、开启MySQL远程访问权限&nbsp;允许远程连接：<br/>解决方法：<br/>a、开启服务端mysql服务对应的端口号，默认3306(设置相关防火墙设置，建立入站规则)；<br/>b、mysql>&nbsp;select&nbsp;host,user,password&nbsp;from&nbsp;user;<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;user&nbsp;|&nbsp;password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>|&nbsp;localhost&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;192.168.1.1&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;root&nbsp;|&nbsp;*A731AEBFB621E354CD41BAF207D884A609E81F5E&nbsp;|<br/>+--------------+------+-------------------------------------------+<br/>3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)<br/>实现远程连接（改表法）<br/>use&nbsp;mysql;<br/><br/>update&nbsp;user&nbsp;set&nbsp;host&nbsp;=&nbsp;'%'&nbsp;where&nbsp;user&nbsp;=&nbsp;'root';<br/>这样在远端就可以通过root用户访问Mysql.<br/>4、具有固定名称“MySql.Data.MySqlClient”的&nbsp;ADO.NET&nbsp;提供程序未在计算机或应用程序配置文件中注册或无法加载<br/>解决方法：<br/>提示是因为“找不到请求的&nbsp;.Net&nbsp;Framework&nbsp;Data&nbsp;Provider。可能没有安装。”<br/>下载mysql-connector-net-6.10.8.msi&nbsp;安装<br/>(服务器，客户端涉及net&nbsp;ef,mysql数据库查询时,需安装相应驱动，版本要一致：mysql-connector-net-6.10.8.msi，mysql-connector-odbc-8.0.13-winx64.msi，mysql-for-visualstudio-1.2.8.msi)<br/>","Author":"Jacee","ImgUrl":"assets/articleImg/mysql填坑系列-1.jpg","CreateDate":"2018-03-12T00:00:00"},{"KID":"43484.668573287","Title":"使用aspnet_regiis.exe重新注册.NET&nbsp;Framework","TitleDescription":"iis&nbsp;部署站点报错","Category":"技术","Content":"一个新的服务器系统环境或者重新安装IIS后，部署了相关访问站点，有时往往还是无法正常访问，<br/>这时你可能需要注意下，需要用aspnet_regiis.exe来注册.NET&nbsp;Framework,。具体如下：<br/>asp.net&nbsp;2.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v2.0.507\\aspnet_regiis.exe&nbsp;-i<br/><br/>asp.net&nbsp;4.0<br/>C:\\WINDOWS\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis.exe&nbsp;-i，<br/>然后重新启动站点。","Author":"Jacee","ImgUrl":"assets/articleImg/aspnetiis-1.jpg","CreateDate":"2017-08-07T00:00:00"},{"KID":"43486.3918905208","Title":".NET设计模式开篇","TitleDescription":".NET&nbsp;设计模式","Category":"技术","Content":"设计模式是规则吗？<br/><br/>地上本没有路，走得人多了也就成了路。设计模式如同此理，它是经验的传承，并非体系；是被前人发现，经过总结形成了一套某一类问题的一般性解决方案，而不是被设计出来的定性规则；它不像算法那样可以照搬照用。<br/><br/>设计模式是架构吗？<br/><br/>架构和模式应该是一个属于相互涵盖的过程，但是总体来说架构更加关注的是所谓的High-Level&nbsp;Design,而模式关注的重点在于通过经验提取的“准则或指导方案”在设计中的应用，因此在不同层面考虑问题的时候就形成了不同问题域上的模式。模式的目标是，把共通问题中的不变部分和变化部分分离出来。不变的部分，就构成了模式，因此，模式是一个经验提取的“准则”，并且在一次一次的实践中得到验证，在不同的层次有不同的模式，小到语言实现，大到架构。在不同的层面上，模式提供不同层面的指导。<br/><br/>设计模式，软件的永恒之道？<br/><br/>这个问题没有答案，有的只是讨论，看一下一位前辈结合建筑学得出的几点心得吧：<br/><br/>和建筑结构一样，软件中亦有诸多的“内力”。和建筑设计一样，软件设计也应该努力疏解系统中的内力，使系统趋于稳定、有生气。一切的软件设计都应该由此出发。<br/><br/>任何系统都需要有变化，任何系统都会走向死亡。作为设计者，应该拥抱变化、利用变化，而不是逃避变化。<br/><br/>好的软件只能“产生”而不能“创造”，我们所能做的只是用一个相对好的过程，尽量使软件朝向好的方向发展。<br/><br/>需要设计模式吗？<br/><br/>答案是肯定的，但你需要确定的是模式的应用是否过度？我得承认，世界上有很多天才的程序员，他可以在一段代码中包含6&nbsp;种设计模式，也可以不用模式而把设计做得很好。但我们的目标是追求有效的设计，而设计模式可以为这个目标提供某种参考模型、设计方法。<br/><br/>我们不需要奉GOF的设计模式为圭臬，但合理的运用设计模式，才是正确的抉择。很多人看过GOF的《Design&nbsp;Patterns》，对这23&nbsp;种模式也背得滚瓜烂熟。但重要的不是你熟记了多少个模式的名称，关键还在于付诸实践的运用。为了有效地设计，而去熟悉某种模式所花费的代价是值得的，因为很快你会在设计中发现这种模式真的很好，很多时候它令得你的设计更加简单了。<br/><br/>其实在软件设计人员中，唾弃设计模式的可能很少，盲目夸大设计模式功用的反而更多。言必谈“模式”，并不能使你成为优秀的架构师。真正出色的设计师，懂得判断运用模式的时机。还有一个问题是，很多才踏入软件设计领域的人员，往往对设计模式很困惑。对于他们来说，由于没有项目的实际经验，OO&nbsp;的思想也还未曾建立，设计模式未免过于高深了。其实，即使是非常有经验的程序员，也不敢夸口对各种模式都能合理应用。[--摘自wayfare的设计之道]","Author":"Jacee","ImgUrl":"assets/articleImg/NET设计模式-00.jpg","CreateDate":"2016-04-06T00:00:00"},{"KID":"43486.6243243403","Title":".NET设计模式-1&nbsp;单件模式001（Singleton&nbsp;Pattern）","TitleDescription":"设计模式&nbsp;单件模式&nbsp;Singleton&nbsp;Pattern","Category":"技术","Content":"概述<br/><br/>Singleton模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。这就提出了一个问题：如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？客户程序在调用某一个类时，它是不会考虑这个类是否只能有一个实例等问题的，所以，这应该是类设计者的责任，而不是类使用者的责任。<br/>从另一个角度来说，Singleton模式其实也是一种职责型模式。因为我们创建了一个对象，这个对象扮演了独一无二的角色，在这个单独的对象实例中，它集中了它所属类的所有权力，同时它也肩负了行使这种权力的职责！<br/><br/>意图：<br/>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br/><br/>1．简单实现<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance=null;<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说并不是安全的，因为在多线程的环境下有可能得到Singleton类的多个实例。如果同时有两个线程去判断（instance&nbsp;==&nbsp;null），并且得到的结果为真，这时两个线程都会创建类Singleton的实例，这样就违背了Singleton模式的原则。实际上在上述代码中，有可能在计算出表达式的值之前，对象实例已经被创建，但是内存模型并不能保证对象实例在第二个线程创建之前被发现。<br/>该实现方式主要有两个优点：<br/><1>、&nbsp;由于实例是在&nbsp;Instance&nbsp;属性方法内部创建的，因此类可以使用附加功能（例如，对子类进行实例化），即使它可能引入不想要的依赖性。<br/><2>、&nbsp;直到对象要求产生一个实例才执行实例化；这种方法称为“惰性实例化”。惰性实例化避免了在应用程序启动时实例化不必要的&nbsp;singleton。<br/>2．安全的线程&nbsp;<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种方式的实现对于线程来说是安全的。我们首先创建了一个进程辅助对象，线程在进入时先对辅助对象加锁然后再检测对象是否被创建，这样可以确保只有一个实例被创建，因为在同一个时刻加了锁的那部分程序只有一个线程可以进入。这种情况下，对象实例由最先进入的那个线程创建，后来的线程在进入时（instence&nbsp;==&nbsp;null）为假，不会再去创建对象实例了。但是这种实现方式增加了额外的开销，损失了性能。<br/>","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43486.6269324769","Title":"NET设计模式-1&nbsp;单件模式002（Singleton&nbsp;Pattern）","TitleDescription":"NET设计模式&nbsp;单件模式","Category":"技术","Content":"<br/>3．双重锁定<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;null;<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;object&nbsp;padlock&nbsp;=&nbsp;new&nbsp;object();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;(padlock)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这种实现方式对多线程来说是安全的，同时线程不是每次都加锁，只有判断对象实例没有被创建时它才加锁，有了我们上面第一部分的里面的分析，我们知道，加锁后还得再进行对象是否已被创建的判断。它解决了线程并发问题，同时避免在每个&nbsp;Instance&nbsp;属性方法的调用中都出现独占锁定。它还允许您将实例化延迟到第一次访问对象时发生。实际上，应用程序很少需要这种类型的实现。大多数情况下我们会用静态初始化。这种方式仍然有很多缺点：无法实现延迟初始化。<br/><br/>4．静态初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>看到上面这段富有戏剧性的代码，我们可能会产生怀疑，这还是Singleton模式吗？在此实现中，将在第一次引用类的任何成员时创建实例。公共语言运行库负责处理变量初始化。该类标记为&nbsp;sealed&nbsp;以阻止发生派生，而派生可能会增加实例。此外，变量标记为&nbsp;readonly，这意味着只能在静态初始化期间（此处显示的示例）或在类构造函数中分配变量。<br/><br/>该实现与前面的示例类似，不同之处在于它依赖公共语言运行库来初始化变量。它仍然可以用来解决&nbsp;Singleton&nbsp;模式试图解决的两个基本问题：全局访问和实例化控制。公共静态属性为访问实例提供了一个全局访问点。此外，由于构造函数是私有的，因此不能在类本身以外实例化&nbsp;Singleton&nbsp;类；因此，变量引用的是可以在系统中存在的唯一的实例。<br/><br/>由于&nbsp;Singleton&nbsp;实例被私有静态成员变量引用，因此在类首次被对&nbsp;Instance&nbsp;属性的调用所引用之前，不会发生实例化。<br/><br/>这种方法唯一的潜在缺点是，您对实例化机制的控制权较少。在&nbsp;Design&nbsp;Patterns&nbsp;形式中，您能够在实例化之前使用非默认的构造函数或执行其他任务。由于在此解决方案中由&nbsp;.NET&nbsp;Framework&nbsp;负责执行初始化，因此您没有这些选项。在大多数情况下，静态初始化是在&nbsp;.NET&nbsp;中实现&nbsp;Singleton&nbsp;的首选方法。<br/><br/>5．延迟初始化<br/>public&nbsp;sealed&nbsp;class&nbsp;Singleton<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Singleton()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;Instance<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Nested.instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Nested<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Nested()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internal&nbsp;static&nbsp;readonly&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>这里，初始化工作有Nested类的一个静态成员来完成，这样就实现了延迟初始化，并具有很多的优势，是值得推荐的一种实现方式。<br/><br/>实现要点<br/><br/>Singleton模式是限制而不是改进类的创建。<br/>Singleton类中的实例构造器可以设置为Protected以允许子类派生。<br/>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。<br/>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。<br/>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。<br/>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。<br/>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。<br/><br/>优点<br/><br/>&nbsp;实例控制：Singleton&nbsp;会阻止其他对象实例化其自己的&nbsp;Singleton&nbsp;对象的副本，从而确保所有对象都访问唯一实例<br/>&nbsp;灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程<br/><br/>缺点<br/><br/>&nbsp;开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题，上面的五种实现方式中已经说过了。<br/><br/>可能的开发混淆：使用&nbsp;singleton&nbsp;对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用&nbsp;new&nbsp;关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。<br/>&nbsp;对象的生存期：Singleton&nbsp;不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于&nbsp;.NET&nbsp;Framework&nbsp;的语言），只有&nbsp;Singleton&nbsp;类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如&nbsp;C++），其他类可以删除&nbsp;<br/>对象实例，但这样会导致&nbsp;Singleton&nbsp;类中出现悬浮引用。<br/><br/>适用性：<br/>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br/>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br/><br/>应用场景：<br/>&nbsp;每台计算机可以有若干个打印机，但只能有一个Printer&nbsp;Spooler，避免两个打印作业同时输出到打印机。&nbsp;<br/>（摘自吕震宇的C#设计模式（7）－Singleton&nbsp;Pattern）<br/><br/>PC机中可能有几个串口，但只能有一个COM1口的实例。<br/>系统中只能有一个窗口管理器。<br/>.NET&nbsp;Remoting中服务器激活对象中的Sigleton对象，确保所有的客户程序的请求都只有一个实例来处理。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/NET设计模式-1.jpg","CreateDate":"2016-04-08T00:00:00"},{"KID":"43487.4469959607","Title":".NET设计模式-2：抽象工厂模式（Abstract&nbsp;Factory）001","TitleDescription":".NET设计模式&nbsp;抽象工厂模式","Category":"技术","Content":"概述<br/><br/>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时由于需求的变化，往往存在着更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象的创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？这就是我们要说的抽象工厂模式。<br/><br/>意图<br/>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br/><br/>解决方案是增加一个抽象工厂类AbstractFactory，增加一个静态方法，该方法根据一个配置文件(App.config或者Web.config)&nbsp;一个项(比如factoryName)动态地判断应该实例化哪个工厂类，<br/>抽象工厂类中为了避免条件判断语句，可以使用.NET中反射机制：<br/>using&nbsp;System;<br/>using&nbsp;System.Reflection;<br/><br/>namespace&nbsp;AbstractFactory<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;<summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;AbstractFactory类<br/>&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;</summary><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractFactory&nbsp;GetInstance()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;factoryName&nbsp;=&nbsp;Constant.STR_FACTORYNAME.ToString();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;instance;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(factoryName&nbsp;!=&nbsp;\"\")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;(AbstractFactory)&nbsp;Assembly.Load(factoryName).CreateInstance(factoryName);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;null;<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Tax&nbsp;CreateTax();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;Bonus&nbsp;CreateBonus();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/><?&nbsp;xml&nbsp;version=\"1.0\"&nbsp;encoding=\"utf-8\"&nbsp;?><br/><configuration><br/>&nbsp;&nbsp;&nbsp;&nbsp;<appSettings><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<add&nbsp;key&nbsp;=&nbsp;\"factoryName\"&nbsp;value=\"AmericanFactory\"></add><br/>&nbsp;&nbsp;&nbsp;&nbsp;</appSettings><br/></configuration><br/><br/>完完全全地理解抽象工厂模式的意义非常重大，可以说对它的理解是你对OOP理解上升到一个新的里程碑的重要标志。&nbsp;学会了用抽象工厂模式编写框架类，你将理解OOP的精华:面向接口编程.。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/抽象工厂模式001.jpg","CreateDate":"2016-04-18T00:00:00"},{"KID":"43487.5564431134","Title":".NET设计模式-3：建造者模式（Builder&nbsp;Pattern）","TitleDescription":".NET设计模式&nbsp;建造者模式","Category":"","Content":"概述<br/>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br/><br/>意图<br/>建造者的特点是过程，需要建造对象的过程是一样的，如：软件项目，过程都是，POC、投标、立项、软件过程、收款，那么标准的软件项目都是这个过程，只是不同的项目在做这个过程的内容不一样。所以需要有一个过程，这个过程需要被抽象出来（接口化），不同的项目实现不同的过程。<br/>上面的过程，是有顺序的，POC、投标、立项、软件过程、收款，这个过程不能乱，所以需要有一个指挥官来固定建造的顺序。<br/>结合上述两点，就是一个建造的的模式了，理论的说法是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br/>理解：<br/><br/>建造者模式通常包括下面几个角色：<br/>1.&nbsp;builder：给出一个抽象接口，以规范产品对象的各个组成部分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。<br/>2.&nbsp;ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。&nbsp;在建造过程完成后，提供产品的实例。<br/>3.&nbsp;Director：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。<br/>4.&nbsp;Product：要创建的复杂对象。<br/>//&nbsp;创建车的过程<br/>public&nbsp;interface&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;GetCar();<br/>}<br/>//&nbsp;A车<br/>public&nbsp;class&nbsp;ConcreteBuilderA&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;A&nbsp;Car&nbsp;part2\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;B车<br/>public&nbsp;class&nbsp;ConcreteBuilderB&nbsp;:&nbsp;IBuilder<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartA()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuildPartB()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;car.Add(\"Build&nbsp;B&nbsp;Car&nbsp;part1\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car&nbsp;GetCar()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;car;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;车对象<br/>public&nbsp;class&nbsp;Car<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&nbsp;parts&nbsp;=&nbsp;new&nbsp;ArrayList();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Add(string&nbsp;part)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.Add(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Show()<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(\"&nbsp;Car&nbsp;Parts&nbsp;-------\");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(string&nbsp;part&nbsp;in&nbsp;parts)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(part);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>//&nbsp;指挥者<br/>public&nbsp;class&nbsp;Director<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;BuilderCar(IBuilder&nbsp;builder)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildPartB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}<br/>static&nbsp;void&nbsp;Main(string[]&nbsp;args)<br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指挥者<br/>&nbsp;&nbsp;&nbsp;&nbsp;Director&nbsp;director&nbsp;=&nbsp;new&nbsp;Director();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b1&nbsp;=&nbsp;new&nbsp;ConcreteBuilderA();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建造对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;IBuilder&nbsp;b2&nbsp;=&nbsp;new&nbsp;ConcreteBuilderB();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象1<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c1&nbsp;=&nbsp;b1.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c1.Show();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行对象2<br/>&nbsp;&nbsp;&nbsp;&nbsp;director.BuilderCar(b2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;Car&nbsp;c2&nbsp;=&nbsp;b2.GetCar();<br/>&nbsp;&nbsp;&nbsp;&nbsp;c2.Show();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadKey();<br/>}<br/><br/>总结：<br/>1.使用建造者模式可以使客户端不必知道产品内部组成的细节。<br/>2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。<br/>3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。","Author":"Jacee-转载","ImgUrl":"assets/articleImg/建造者模式0419.jpg","CreateDate":"2016-04-19T00:00:00"},{"KID":"43487.6299352315","Title":"软件开发项目管理浅谈-1","TitleDescription":"项目管理","Category":"技术","Content":"谈到项目管理，很多时候如果不真正的实践，很容易误解。我也曾经认为项目管理是件很轻松容易的事情，无非是按需求组织工程团队完成任务。可真正实践的时候才发现项目管理涉及到很多的知识，技术和工具链。成熟的项目管理体系是保证项目成败的技术保证，而项目管理者是这个项目保证的实际操刀者，是项目的灵魂人物，其对流程的理解和把握直接影响项目的质量。以下是几个分析点：<br/>1.&nbsp;可行性分析&nbsp;(Feasibility)<br/>很多时候,&nbsp;我们在开发项目的时候对这一步几乎没有足够重视,&nbsp;或者说对系统的估计不足,&nbsp;亦或无从下手.?所以在开发后期经常遇到难以克服的瓶颈和系统缺陷,&nbsp;影响客户对系统的满意度.?那么怎么来做可行性分析呢?&nbsp;<br/>(A)&nbsp;系统可行性&nbsp;-&nbsp;目标系统是否可以支持???有没有系统限制?&nbsp;是否可以克服?<br/>(B)&nbsp;功能可行性&nbsp;-&nbsp;项目中的各项需求是否都能完整实现,&nbsp;有没有功能限制?<br/>(C)&nbsp;资源可行性&nbsp;-&nbsp;项目的时间,&nbsp;人员,&nbsp;设备,?环境[库]....<br/>【注】可行性分析一定要多方人员的参与,&nbsp;不仅仅是项目负责人的事情.<br/>2.&nbsp;架构设计&nbsp;(Architecture)<br/>一般这一步是架构师来考虑的,&nbsp;但架构设计的系统适应性也常常关乎项目的成败.&nbsp;<br/>(A)&nbsp;可行性&nbsp;-&nbsp;这指的是这个机制能够达到预定需求,?这个是最基本的.<br/>(B)&nbsp;可靠性&nbsp;-&nbsp;架构一定下来,&nbsp;就很难改变,&nbsp;所以模块化程度和稳定性通常是应该考虑的.<br/>(C)&nbsp;可扩展性&nbsp;-&nbsp;主要指代码复用,&nbsp;功能复用和扩展,&nbsp;接口通用.<br/>3.&nbsp;项目开发&nbsp;(Implementation)<br/>这个过程中主要涉及到项目的具体实现和实施,?进度控制是重点,&nbsp;也因此会带来各方的资源平衡和有效的沟通.可以从以下几个方面来跟进.<br/>(A)&nbsp;进度报告&nbsp;-&nbsp;定期的PSR,&nbsp;让项目成员和利益相关者了解项目的情况和面临的问题.<br/>(B)&nbsp;开放问题讨论&nbsp;-&nbsp;组织项目组人员和技术专家对已经开发的问题分析和寻求解决方案.<br/>(C)&nbsp;文档更新&nbsp;-&nbsp;定期更新相关项目文档,&nbsp;包括需求,?设计,&nbsp;测试计划等等一系列文档.<br/>4.&nbsp;项目总结&nbsp;(Summary)<br/><br/>很多时候,&nbsp;这一步也容易被轻视,?毕竟项目进行到这里各方都需要调整一下,?轻松一下了,&nbsp;呵呵.&nbsp;庆祝的同时,&nbsp;这个关键的一步也不能少,&nbsp;这可以为我们以后的项目提供宝贵的信息和有建设性的意见.以下是几个总结点：<br/>(A)&nbsp;内存需求&nbsp;-&nbsp;总共耗费了多少内存,&nbsp;代码量增加了多少.<br/>(B)&nbsp;新增接口&nbsp;-&nbsp;有没有新的接口增加<br/>(C)&nbsp;主要限制&nbsp;-&nbsp;项目有没有限制,&nbsp;是否是之前没有预计的?&nbsp;有没有发现新的系统限制?<br/>(D)&nbsp;主要问题分析&nbsp;-&nbsp;项目中出现的各种突出问题(包括技术和非技术性的)分析<br/>(E)&nbsp;亮点分析&nbsp;-&nbsp;项目过程中有什么值得我们借鉴和推广的。","Author":"Jacee","ImgUrl":"assets/articleImg/软件开发项目管理浅谈001.jpg","CreateDate":"2015-10-14T00:00:00"}]}
